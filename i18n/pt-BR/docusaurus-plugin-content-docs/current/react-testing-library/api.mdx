---
id: api
title: API
---

A `React Testing Library` re-exporta tudo da `DOM Testing Library` assim como
esses m√©todos:

- [`render`](#render)
- [`render` Options](#render-options)
  - [`container`](#container)
  - [`baseElement`](#baseelement)
  - [`hydrate`](#hydrate)
  - [`wrapper`](#wrapper)
  - [`queries`](#queries)
- [`render` Result](#render-result)
  - [`...queries`](#queries-1)
  - [`container`](#container-1)
  - [`baseElement`](#baseelement-1)
  - [`debug`](#debug)
  - [`rerender`](#rerender)
  - [`unmount`](#unmount)
  - [`asFragment`](#asfragment)
- [`cleanup`](#cleanup)
- [`act`](#act)

---

## `render`

```typescript
function render(
  ui: React.ReactElement<any>,
  options?: {
    /* Voc√™ n√£o vai usar isso frequentemente, des√ßa para mais informa√ß√µes sobre as options */
  },
): RenderResult
```

Renderiza em um container que √© anexado ao `document.body`.

```jsx
import {render} from '@testing-library/react'

render(<div />)
```

```jsx
import {render} from '@testing-library/react'
import '@testing-library/jest-dom'

test('renderiza uma mensagem', () => {
  const {container, getByText} = render(<Greeting />)
  expect(getByText('Ol√°, Mundo!')).toBeInTheDocument()
  expect(container.firstChild).toMatchInlineSnapshot(`
    <h1>Ol√°, Mundo!</h1>
  `)
})
```

## `render` Options

Voc√™ n√£o vai precisar especificar as op√ß√µes frequentemente, mas se voc√™ precisar
em algum moment aqui est√£o as op√ß√µes dispon√≠veis que voc√™ pode usar como segundo
argumento para o `render`.

### `container`

Por padr√£o, a `React Testing Library` vai criar uma `div` e anex√°-la ao
`document.body` que √© onde o seu componente React vai ser renderizado. Se voc√™
passar o seu pr√≥prio HTMLElement `container` por essa op√ß√£o, ele n√£o ser√°
anexado ao `document.body` automaticamente.

Por exemplo: Se voc√™ est√° testando unitariamente um elemento `tablebody`, ele
n√£o poder√° ser uma child de uma `div`. Nesse caso, voc√™ pode especificar uma
`table` como o render `container`.

```jsx
const table = document.createElement('table')

const {container} = render(<TableBody {...props} />, {
  container: document.body.appendChild(table),
})
```

### `baseElement`

Se o `container` for especificado, ent√£o o padr√£o √© ele mesmo, do contr√°rio o
padr√£o √© o `document.body`. Ele √© utilizado como o elemento base para as queries
assim como o que √© mostrado quando voc√™ usa o `debug()`.

### `hydrate`

Se o hydrate √© definido como true, ent√£o ser√° renderizado com o
[ReactDOM.hydrate](https://reactjs.org/docs/react-dom.html#hydrate). Isso pode
ser √∫til se voc√™ estiver usando SSR (server-side rendering) e usa o
ReactDOM.hydrate para montar seus componentes.

### `wrapper`

Passa um Componente React como a op√ß√£o `wrapper` para ser renderizado ao redor
de um elemento interno. Isso √© bem √∫til para criar fun√ß√µes customizadas de
renderiza√ß√£o para providers comuns de informa√ß√£o. Veja
[configura√ß√£o](setup.mdx#custom-render) para exemplos.

### `queries`

Queries para vincular. Sobrescreve o conjunto padr√£o do `DOM Testing Library` a
menos que seja "mergeado".

```js
// Exemplo, uma fun√ß√£o para percorrer o conte√∫do da tabela
import * as tableQueries from 'my-table-query-library'
import {queries} from '@testing-library/react'

const {getByRowColumn, getByText} = render(<MyTable />, {
  queries: {...queries, ...tableQueries},
})
```

Veja [helpers](dom-testing-library/api-custom-queries.mdx) para orienta√ß√£o em
como usar fun√ß√µes de utilidade para criar queries customizadas.

Queries customizadas tamb√©m podem ser adicionadas globalmente seguindo o
[Guia de renderiza√ß√£o customizada](setup.mdx#custom-render).

## `render` Result

O m√©todo `render` retorna um objeto que cont√©m algumas propriedades:

### `...queries`

A feature mais importante do `render` √© que as queries do
[DOM Testing Library](queries/about.mdx) s√£o automaticamente retornadas com seus
primeiros argumentos ligados ao [baseElement](#baseelement), cujo padr√£o √© o
`document.body`.

Veja [Queries](queries/about.mdx) para uma listagem completa.

**Exemplo**

```jsx
const {getByLabelText, queryAllByTestId} = render(<Component />)
```

### `container`

O n√≥ do DOM que est√° contido no seu Elemento React (renderizado usando o
`ReactDOM.render`). √â uma `div`. Esse √© um n√≥ comum do DOM, ent√£o voc√™ pode
chamar `container.querySelector` e etc. para inspecionar seus filhos.

> Dica: Para pegar o elemento raiz do seu elemento renderizado, use
> `container.firstChild`.
>
> NOTA: Quando esse elemento raiz for um
> [React Fragment](https://reactjs.org/docs/fragments.html),
> `container.firstChild` somente ir√° pegar o primeiro filho desse Fragment, n√£o
> o pr√≥prio Fragment.

> üö® Se voc√™ se pegar usando `container` para buscar por elementos renderizados
> ent√£o voc√™ deveria reconsiderar! As outras queries s√£o desenhadas para serem
> mais resilientes √† mudan√ßas que v√£o ser feitas no componente que voc√™ esta
> testando. Evite usar `container` para buscar por elementos!

### `baseElement`

O n√≥ do DOM que onde seu Elemento React √© renderizado no container. Se voc√™ n√£o
especificar o `baseElement` nas op√ß√µes do render, o padr√£o ser√° o
`document.body`.

Isso √© √∫til quando o componente que voc√™ quer testar renderiza algo fora do
container div, exemplo: quando voc√™ quer testar um snapshop de um componente
portal que renderiza seu HTML diretamente no body.

> Nota: as queries retornadas pelo `render` olham para dentro do baseElement,
> assim voc√™ pode usar as queries para testar seu componente portal sem o
> baseElement.

### `debug`

> NOTA: √â recomendado usar o [`screen.debug`](queries/about.mdx#screendebug) ao
> inv√©s do `debug`.

Esse m√©todo √© um atalho para o `console.log(prettyDOM(baseElement))`.

```jsx
import React from 'react'
import {render} from '@testing-library/react'

const HelloWorld = () => <h1>Hello World</h1>
const {debug} = render(<HelloWorld />)
debug()
// <div>
//   <h1>Ol√°, mundo!</h1>
// </div>
// voc√™ tamb√©m pode passar um elemento: debug(getByTestId('messages'))
// e voc√™ pode passar todos os mesmos argumentos para o debug assim como
// voc√™ passa para o prettyDOM:
// const maxLengthToPrint = 10000
// debug(getByTestId('messages'), maxLengthToPrint, {highlight: false})
```

Esse √© um simples wrapper ao redor do `prettyDOM` o qual √© tamb√©m exposto e vem
do [`DOM Testing Library`](dom-testing-library/api-debugging.mdx#prettydom).

### `rerender`

Seria provavelmente melhor se voc√™ testasse o componente que est√° fazendo a
atualiza√ß√£o da prop para garantir que as props est√£o sendo atualizadas
corretamente (Veja
[a Se√ß√£o de Princ√≠pios Orientadores](guiding-principles.mdx)). Dito isto, se
voc√™ preferir atualizar as props de um componente renderizado no seu teste, essa
fun√ß√£o pode ser usada.

```jsx
import {render} from '@testing-library/react'

const {rerender} = render(<NumberDisplay number={1} />)

// renderiza novamente o mesmo componente com props diferentes
rerender(<NumberDisplay number={2} />)
```

[Veja a p√°gina de exemplos](example-update-props.mdx)

### `unmount`

Causa o desmonte de um componente renderizado. Isso √© √∫til para testar o que
acontece quando seu componente √© removido da p√°gina (tipo testar se voc√™ n√£o
deixa event handlers causando memory leaks por a√≠).

> Esse m√©todo √© uma abstra√ß√£o bem pequena do `ReactDOM.unmountComponentAtNode`

```jsx
import {render} from '@testing-library/react'

const {container, unmount} = render(<Login />)
unmount()
// seu componente foi desmontado e agora: container.innerHTML === ''
```

### `asFragment`

Retorna um `DocumentFragment` do seu componente renderizado. Isso pode ser √∫til
se voc√™ precisa evitar live bindings e precisa ver se seu componente reage a
eventos.

```jsx
import React, {useState} from 'react'
import {render, fireEvent} from '@testing-library/react'

const TestComponent = () => {
  const [count, setCounter] = useState(0)

  return (
    <button onClick={() => setCounter(count => count + 1)}>
      Click to increase: {count}
    </button>
  )
}

const {getByText, asFragment} = render(<TestComponent />)
const firstRender = asFragment()

fireEvent.click(getByText(/Click to increase/))

// Isso vai criar um snapshot apenas com as diferen√ßas entre a primeira renderiza√ß√£o, e o
// estado do DOM deposi do evento de click.
// Veja https://github.com/jest-community/snapshot-diff
expect(firstRender).toMatchDiffSnapshot(asFragment())
```

---

## `cleanup`

Desmonta a √°rvore React que montamos com o [render](#render).

> Por favor, note que isso √© feito de forma autom√°tica se o framework de testes
> que voc√™ est√° usando suporta o `afterEach` global e √© injetado no seu ambiente
> de testes (como mocha, Jest, and Jasmine). Se n√£o, voc√™ precisar√° fazer
> limpezas manuais ap√≥s cada um dos testes.

Por exemplo, se voc√™ estiver usando o framework de testes
[ava](https://github.com/avajs/ava), ent√£o voc√™ precisar√° utilizar o hook
`test.afterEach` assim:

```jsx
import {cleanup, render} from '@testing-library/react'
import test from 'ava'

test.afterEach(cleanup)

test('renders into document', () => {
  render(<div />)
  // ...
})

// ... mais testes ...
```

Falhas ao chamar o `cleanup` quando voc√™ chamou `render` podem resultar em
memory leaks e testes que n√£o s√£o "idempotentes" (os quais podem levar a
dificuldades para debugar erros nos seus testes)

---

## `act`

Esse √© um wrapper leve acerca do
[`react-dom/test-utils` fun√ß√£o `act`](https://reactjs.org/docs/test-utils.html#act).
Tudo que ele faz √© passar todos os argumentos para a fun√ß√£o act se sua vers√£o
suportar o `act`. √â recomendado o uso da importa√ß√£o da `@testing-library/react`
no lugar de react-dom/test-utils` por raz√µes de consist√™ncia.
